SQL Server Architecture

SQL Server architecture defines the structure and components that make up SQL Server, including the database engine, services, and layers involved in data processing, storage, and management. SQL Server operates on a client-server model, where the Database Engine handles data management and user requests, while clients (applications, management tools) send queries and retrieve data from the server.

SQL Server architecture can be broadly divided into three primary layers:

- Protocol Layer

- Relational Engine (Query Processor)

- Storage Engine

Additional components such as TempDB, Lock Manager, Transaction Manager, and services support the efficient functioning of SQL Server.


1) Protocol Layer

The Protocol Layer facilitates communication between SQL Server and client applications. It ensures data is transferred correctly over the network using the Tabular Data Stream (TDS) protocol.

Key Protocols:

- Shared Memory: Used for local connections when SQL Server and client are on the same machine. Most efficient for local access.

- TCP/IP: Standard protocol for remote connections between clients and SQL Server.

- Named Pipes: Used for communication within a local network or on the same machine. Less efficient for remote connections.

- TDS (Tabular Data Stream): Transports queries, results, and metadata between client and server in a consistent format.

Optional: VIA (Virtual Interface Adapter) is legacy and rarely used.

Working:
When a client executes a query, the request passes through the protocol layer. The protocol layer packages the query in TDS packets and sends it to SQL Server. Results are returned via the same channel.


2) Relational Engine (Query Processor)

The Relational Engine is responsible for parsing, optimizing, and executing SQL queries. It transforms SQL statements into operations executable on underlying data.

Components:

- Command Parser (CMD Parser):

     Checks SQL statements for syntax and semantic errors.

     Generates a parse tree / query tree representing the query structure.

- Query Optimizer:

     Determines the most efficient execution plan based on available indexes, statistics, and resources.

     Uses a cost-based optimization approach to minimize query execution time.

- Query Executor:

     Executes the query plan generated by the optimizer.

     Interacts with the Storage Engine to retrieve or modify data.

- Execution Plans:

     Estimated Execution Plan: Shows the optimizer’s plan before execution.

     Actual Execution Plan: Includes runtime statistics after query execution.

Working:
When a query arrives:

CMD Parser parses the SQL query.

Optimizer evaluates multiple execution strategies and chooses the best plan.

Query Executor carries out the operations, fetching or updating data via the Storage Engine.


3) Storage Engine

The Storage Engine handles all physical storage, data retrieval, and transaction management. It ensures data integrity, efficient access, and recovery.

Key Components:

Data Files & File Types:

- Primary Data File (.mdf): Stores system and user data. Mandatory.

- Secondary Data File (.ndf): Optional, used for scaling storage.

- Transaction Log File (.ldf): Records all transactions to ensure durability.

- TempDB (.mdf/.ndf): Temporary storage for intermediate operations, sorting, and versioning.

- Access Methods: Determines how data is retrieved from tables or indexes (e.g., table scan, index seek, index scan, bookmark lookup).

- Buffer Manager:

     Manages memory cache (buffer pool) for frequently accessed data pages.

     Reduces disk I/O by keeping recently used pages in memory.

     Works with the Lazy Writer process to flush dirty pages to disk.

- Plan Cache:

     Stores compiled execution plans to avoid re-compiling repeated queries.

     Improves performance and reduces CPU usage.

- Transaction Manager:

     Ensures ACID compliance: Atomicity, Consistency, Isolation, Durability.

     Coordinates with Log Manager and Lock Manager.

     Handles commit and rollback operations.

- Lock Manager:

     Manages locks (shared, exclusive, update) to maintain concurrency control.

- Log Manager:

     Writes transaction records to .ldf files.

     Coordinates checkpoints to persist changes to disk.

- Checkpoints: Periodically flush dirty pages from memory to disk to minimize recovery time in case of a crash.

4) SQL Server Services (Optional Overview)

While the above three layers form the core architecture, SQL Server also provides several support services:

SQL Server Agent: Automates scheduled jobs and maintenance tasks.

Full-Text Search: Enables searching of text-based content efficiently.

Integration Services (SSIS): ETL operations for data integration.

Reporting Services (SSRS): Provides reporting capabilities.

Analysis Services (SSAS): Provides OLAP and data mining solutions.

5) Data Flow Example

Client sends a query via protocol layer (TDS).

Relational Engine parses, optimizes, and executes the query plan.

Storage Engine retrieves or modifies data using buffer pool, locks, and transaction logs.

Results return to the client via the protocol layer.

✅ Advantages of this Architecture:

Clear separation of query processing and storage responsibilities.

Efficient memory and transaction management.

Supports scalability and high concurrency.

Provides fault tolerance and recovery mechanisms.
